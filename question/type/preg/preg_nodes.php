<?php
// This file is part of Preg question type - https://code.google.com/p/oasychev-moodle-plugins/
//
// Preg question type is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Defines generic node classes, generated by parser. These nodes will be usually aggregated in engine-specific classes.
 * These classes are used primarily to store data, so their variable memebers are public.
 *
 * @package    qtype_preg
 * @copyright  2012 Oleg Sychev, Volgograd State Technical University
 * @author     Oleg Sychev <oasychev@gmail.com>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

global $CFG;
require_once($CFG->dirroot . '/question/type/preg/preg_unicode.php');

/**
 * Represents a node or a lexem position in 2 ways: "absolute" (considering the whole string)
 * and "relative" (considering lines and columns).
 */
class qtype_preg_position {
    /** First index of something (absolute positioning). */
    public $indfirst = -1;
    /** Last index of something (absolute positioning). */
    public $indlast = -1;
    /** Index of the line where something begins. */
    public $linefirst = -1;
    /** Index of the line where something ends. */
    public $linelast = -1;
    /** Index of the first character on the first line. */
    public $colfirst = -1;
    /** Index of the last character on the last line. */
    public $collast = -1;

    public function __construct($indfirst = -1, $indlast = -1, $linefirst = -1, $linelast = -1, $colfirst = -1, $collast = -1) {
        $this->indfirst = $indfirst;
        $this->indlast = $indlast;
        $this->linefirst = $linefirst;
        $this->linelast = $linelast;
        $this->colfirst = $colfirst;
        $this->collast = $collast;
    }

    public function compose($with) {
        return new qtype_preg_position($this->indfirst, $with->indlast,
                                       $this->linefirst, $with->linelast,
                                       $this->colfirst, $with->collast);
    }

    public function add_chars_left($count) {
        return new qtype_preg_position($this->indfirst + $count, $this->indlast,
                                       $this->linefirst, $this->linelast,
                                       $this->colfirst + $count, $this->collast);
    }

    public function add_chars_right($count) {
        return new qtype_preg_position($this->indfirst, $this->indlast + $count,
                                       $this->linefirst, $this->linelast,
                                       $this->colfirst, $this->collast + $count);
    }

    public function left() {
        return new qtype_preg_position($this->indfirst, $this->indfirst,
                                       $this->linefirst, $this->linefirst,
                                       $this->colfirst, $this->colfirst);
    }

    public function right() {
        return new qtype_preg_position($this->indlast, $this->indlast,
                                       $this->linelast, $this->linelast,
                                       $this->collast, $this->collast);
    }
}

/**
 * Representation of nodes and leafs as they were typed in the regex.
 */
class qtype_preg_userinscription {
    /** String with the leaf itself. */
    public $data = '';
    /** Subype of the flag in case of \w, \d, [:alnum:] or something. See charset_flag constants. */
    public $isflag = null;

    public function __construct($data = '', $isflag = null) {
        $this->data = $data;
        $this->isflag = $isflag;
    }

    public function __toString() {
        return $this->data;
    }

    /**
     * Checks if it's a simple character like a, b or й.
     */
    public function is_single_character() {
        return $this->isflag === null &&
               core_text::strlen($this->data) == 1;
    }

    public function is_character_range() {
        if ($this->isflag !== null) {
            return false;
        }
        $mpos = core_text::strpos($this->data, '-');
        return $mpos !== null && $mpos > 0 && $mpos < core_text::strlen($this->data) - 1;
    }

    /**
     * Checks if it's a valid (with a special meaning) escape sequence.
     */
    public function is_valid_escape_sequence() {
        if ($this->is_character_range()) {
            return false;
        }
        $allowed = array('a', 'b', 'c', 'e', 'f', 'n', 'r', 't', '0', 'o', 'x',
                         'd', 'D', 'h', 'H', 's', 'S', 'v', 'V', 'w', 'W',
                         'p', 'P');
        return core_text::strlen($this->data) > 1 && $this->data[0] == '\\' &&
               (in_array($this->data[1], $allowed) || ctype_digit(core_text::substr($this->data, 1)));
    }

    /**
     * Checks if it's one of the following characters: \a \b \e \f \n \r \t
     */
    public function is_single_escape_sequence_character() {
        if ($this->isflag !== null || !$this->is_valid_escape_sequence()) {
            return false;
        }
        $allowed = array('a', 'b', 'e', 'f', 'n', 'r', 't');
        return in_array($this->data[1], $allowed);
    }

    /**
     * Checks if it's a character represented as \cx
     */
    public function is_single_escape_sequence_character_c() {
        if ($this->isflag !== null || !$this->is_valid_escape_sequence()) {
            return false;
        }
        return $this->data[1] == 'c';
    }

    /**
     * Checks if it's a character represented as \ddd
     */
    public function is_single_escape_sequence_character_oct() {
        if ($this->isflag !== null || !$this->is_valid_escape_sequence()) {
            return false;
        }
        return $this->data[1] == '0' ||
               (core_text::strlen($this->data) > 2 && $this->data[1] == 'o' && $this->data[2] == '{') ||
               ctype_digit(core_text::substr($this->data, 1));
    }

    /**
     * Checks if it's a character represented as \xhh of \x{hh}
     */
    public function is_single_escape_sequence_character_hex() {
        if ($this->isflag !== null || !$this->is_valid_escape_sequence()) {
            return false;
        }
        return $this->data[1] == 'x';
    }

    public function is_posix_flag() {
        return $this->isflag !== null && $this->data[0] == '[';
    }

    public function is_uprop_flag() {
        return $this->isflag !== null && $this->data[0] == '\\' && ($this->data[1] == 'p' || $this->data[1] == 'P');
    }

    public function is_slash_flag() {
        return $this->isflag !== null && !$this->is_uprop_flag() && $this->data[0] == '\\';
    }

    public function is_flag_negative() {
        if (!$this->isflag) {
            return false;
        }
        if ($this->data[0] == '\\') {
            return ctype_upper($this->data[1]); // Fortunately, this works both for \W and, for example, \PL    TODO: \Z, \A
        }
        if ($this->data[0] == '[') {
            return $this->data[2] == '^';
        }
        return false;
    }

    public function lang_key($usedescription = false) {
        if ($this->isflag === null || !$usedescription) {
            return $this->isflag;
        }
        $result = 'description_charflag_' . $this->isflag;
        if ($this->is_flag_negative()) {
            $result .= '_neg';
        }
        return $result;
    }
}

/**
 * Class for plain lexems (not complete nodes), they contain position information too.
 */
class qtype_preg_lexem {
    /** An instance of qtype_preg_position. */
    public $position = null;
    /** An instance of qtype_preg_userinscription. */
    public $userinscription = null;

    /**
     * Sets position and userinscription for the node.
     */
    public function set_user_info($position, $userinscription = array()) {
        $this->position = $position;
        $this->userinscription = $userinscription;
    }

    public function plain_userinscription() {
        $result = '';
        foreach ($this->userinscription as $ui) {
            $result .= $ui;
        }
        return $result;
    }
}

/**
 * The interface for objects that are passed to qtype_preg_leaf::match(), qtype_preg_leaf::consumes(), qtype_preg_leaf::next_character() as $matcherstateobj.
 */
interface qtype_preg_matcher_state {

    /**
     * Is the match full?
     */
    public function is_full();

    public function start_pos();

    /**
     * Returns index of the first character matched for the given subexpression.
     */
    public function index_first($subexpression = 0);

    /**
     * Returns the length of the given subexpression.
     */
    public function length($subexpression = 0);

    /**
     * Returns whether the given subexpression is captured.
     */
    public function is_subexpr_captured($subexpression = 0);

    /**
     * Checks if the state is in a recursive call.
     */
    public function is_recursion($subexpression = 0);
}

/**
 * Generic node class.
 */
abstract class qtype_preg_node {

    /** A character or a character set. */
    const TYPE_LEAF_CHARSET = 'leaf_charset';
    /** Meta-character or escape sequence matching with a set of characters that couldn't be enumerated. */
    const TYPE_LEAF_META = 'leaf_meta';
    /** Simple assert: ^ $ or escape-sequence. */
    const TYPE_LEAF_ASSERT = 'leaf_assert';
    /** Back reference to a subexpression. */
    const TYPE_LEAF_BACKREF = 'leaf_backref';
    /** Recursive match. */
    const TYPE_LEAF_SUBEXPR_CALL = 'leaf_subexpr_call';
    /** Template leaf (without params). */
    const TYPE_LEAF_TEMPLATE = 'leaf_template';
    /** Backtracking control, newline conventions etc sequences. */
    const TYPE_LEAF_CONTROL = 'leaf_control';
    /** Option set. */
    const TYPE_LEAF_OPTIONS = 'leaf_options';
    /** Finite quantifier. */
    const TYPE_NODE_FINITE_QUANT = 'node_finite_quant';
    /** Infinite quantifier. */
    const TYPE_NODE_INFINITE_QUANT = 'node_infinite_quant';
    /** Concatenation. */
    const TYPE_NODE_CONCAT = 'node_concat';
    /** Alternation. */
    const TYPE_NODE_ALT = 'node_alt';
    /** Assert with expression within. */
    const TYPE_NODE_ASSERT = 'node_assert';
    /** Subexpression. */
    const TYPE_NODE_SUBEXPR = 'node_subexpr';
    /** Conditional subexpression. */
    const TYPE_NODE_COND_SUBEXPR = 'node_cond_subexpr';
    /** Template node (with params). */
    const TYPE_NODE_TEMPLATE = 'node_template';
    /** Error node. */
    const TYPE_NODE_ERROR = 'node_error';
    const TYPE_LEAF_COMPLEX_ASSERT = 'leaf_complex_assert';

    /** Type one the node - should be equal to a constant defined in this class. */
    public $type;
    /** Subtype, defined by a child class. */
    public $subtype;
    /** Errors found for this particular node. */
    public $errors = array();
    /** An instance of qtype_preg_position. */
    public $position = null;
    /** An array of qtype_preg_userinscription objects. */
    public $userinscription = null;
    /** Identifier of this node. */
    public $id = -1;
    /** Subpattern number. */
    public $subpattern = -1;
    /** Nullable, firstpos, lastpos used to be needed for nfa/dfa construction. Now they are needed for authoring tools. */
    public $nullable = null;
    public $firstpos = null;
    public $lastpos = null;

    public function __construct() {

    }

    public function __clone() {
        if ($this->position !== null) {
            $this->position = clone $this->position;
        }
    }

    /**
     * Is this node a subpattern? According to Glenn Fowler's "An Interpretation of the POSIX regex Standard",
     * a subpattern is a leaf, or a subexpression, or a quantifier.
     */
    abstract public function is_subpattern();

    /**
     * Calculates nullable, firstpos, lastpos and followpos for this node.
     * @param followpos array to store the followpos map.
     */
    abstract public function calculate_nflf(&$followpos);

    /**
     * Finds the nearest suitable subtree by given indexes in the regex string. If the node is N-ary,
     * expands it to be binary for better precision, thus AST is modified. All passed indexes are updated
     * to the indexes of the found subtree.
     */
    public function node_by_regex_fragment($indexfirst, $indexlast, &$idcounter) {
        if ($indexfirst - $indexlast == 1) {
            // Special case: fictive leaves.
            $current = array($this);
            while (count($current) > 0) {
                $tmp = array_pop($current);
                if ($tmp->position->indfirst == $indexfirst && $tmp->position->indlast == $indexlast) {
                    return $tmp;
                }
                if (is_a($tmp, 'qtype_preg_operator')) {
                    $current = array_merge($current, $tmp->operands);
                }
            }
            return null;
        }

        $result = $this;
        $found = is_a($result, 'qtype_preg_leaf');

        // Go down the tree.
        while (!$found) {
            $replaced = false;
            foreach ($result->operands as $operand) {
                $better_than_result = ($operand->position->indfirst >= $result->position->indfirst) && ($operand->position->indlast <= $result->position->indlast);

                $suits_needed = ($operand->position->indfirst <= $indexfirst) && ($operand->position->indlast >= $indexlast);

                if ($better_than_result && $suits_needed) {
                    $result = $operand;
                    $replaced = true;
                }
            }
            $found = !$replaced || is_a($result, 'qtype_preg_leaf');
        }

        $found = ($result->position->indfirst <= $indexfirst) && ($result->position->indlast >= $indexlast);

        if (!$found) {
            return null;
        }

        // Expand N-ary nodes for better precision.
        if (is_a($result, 'qtype_preg_operator')) {
            $count = count($result->operands);
            $from = 0;
            $to = $count - 1;

            for ($i = 0; $i < $count; $i++) {
                $operand = $result->operands[$i];
                if ($operand->position->indfirst <= $indexfirst) {
                    $from = $i;
                }
                $operand = $result->operands[$count - $i - 1];
                if ($operand->position->indlast >= $indexlast) {
                    $to = $count - $i - 1;
                }
            }

            if ($result->is_expandable()) {
                $result->expand($from, $to, $idcounter);
            }

            // Update the result again.
            foreach ($result->operands as $operand) {
                $better_than_result = ($operand->position->indfirst >= $result->position->indfirst) && ($operand->position->indlast <= $result->position->indlast);
                $suits_needed = ($operand->position->indfirst <= $indexfirst) && ($operand->position->indlast >= $indexlast);
                if ($better_than_result && $suits_needed) {
                    $result = $operand;
                }
            }
        }

        return $result;
    }

    /**
     * Expands the subtrees of operands at the given indexes.
     */
    public function expand($from, $to, &$idcounter, $expandsubtree = false) {
    }

    /**
     * Expands the subtrees of all operands.
     */
    public function expand_all(&$idcounter, $expandsubtree = false) {
    }

    /**
     * Sets position and userinscription for the node.
     */
    public function set_user_info($position, $userinscription = array()) {
        $this->position = $position;
        $this->userinscription = $userinscription;
    }

    public function plain_userinscription() {
        $result = '';
        foreach ($this->userinscription as $ui) {
            $result .= $ui;
        }
        return $result;
    }

    /**
     * Returns the key for this node in the lang file.
     */
    public function lang_key($usedescription = false) {
        return $usedescription ? 'description_' . $this->subtype : $this->subtype;
    }

    /**
     * May be overloaded by childs to change name using data from $this->pregnode.
     */
    public function ui_nodename() {
        return get_string($this->type, 'qtype_preg');
    }

    /**
     * Checks that the two nodes are equivalent
     * @param $node qtype_preg_node other node
     * @param $numberoffset int to recalculate numbers of inner nodes
     * @return bool is $node equals to this node
     */
    public function is_equal($node, $numberoffset) {
        return is_a($this, get_class($node)) // subclass?
            && $this->type == $node->type
            && $this->subtype == $node->subtype;
    }

    /**
     * Finds all occurrences of $node subtree in the current tree
     * @param $node qtype_preg_node subtree to find
     * @param $numberoffset int number of current subexpr to recalculate numbers of inner nodes
     * @return array array of roots of founded subtrees
     */
    public abstract function find_all_subtrees($node, $numberoffset);

}

/**
 * Generic leaf class.
 */
abstract class qtype_preg_leaf extends qtype_preg_node {

    /** Constants that can be returned from next_character for special cases. */
    const NEXT_CHAR_OK              = 0x00;
    const NEXT_CHAR_CANNOT_GENERATE = 0x01;
    const NEXT_CHAR_END_HERE        = 0x02;

    /** Is matching case insensitive? */
    public $caseless = false;
    /** Is this leaf negative? */
    public $negative = false;

    public function is_subpattern() {
        return true;    // Any leaf is a subpattern.
    }

    public function calculate_nflf(&$followpos) {
        // The following is true for almost all leafs, except emptiness.
        $this->nullable = false;
        $this->firstpos = array($this->id);
        $this->lastpos = array($this->id);
    }

    public function lang_key($usedescription = false) {
        $result = parent::lang_key($usedescription);
        if ($usedescription && $this->negative) {
            $result .= '_neg';
        }
        return $result;
    }

    public static function contains_node_of_subtype($subtype, $nodesarray) {
        foreach ($nodesarray as $node) {
            if ($node->subtype == $subtype) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns intersection of leafs.
     *
     * @param other another leaf for intersection.
     */
    public function intersect_leafs($other, $thishastags, $otherhastags) {
        $result = null;
        $length = 0;
        $str = new qtype_poasquestion\string("\n");
        if ($this->type == qtype_preg_node::TYPE_LEAF_CHARSET) {
            if ($other->type == qtype_preg_node::TYPE_LEAF_CHARSET) {
                $result = $this->intersect_with_ranges($other);
            } else if ($this->type == qtype_preg_node::TYPE_LEAF_META && $otherhastags) {
                $result = $this;
            }
        } else if ($this->type == qtype_preg_node::TYPE_LEAF_META && $this->subtype == qtype_preg_leaf_meta::SUBTYPE_EMPTY) {
            if ($other->type == qtype_preg_node::TYPE_LEAF_META && $other->subtype == qtype_preg_leaf_meta::SUBTYPE_EMPTY) {
                $result = new qtype_preg_leaf_meta(qtype_preg_leaf_meta::SUBTYPE_EMPTY);
            } else if ($other->type == qtype_preg_node::TYPE_LEAF_CHARSET && $thishastags) {
                $result = $other;
            } else if ($other->type == qtype_preg_node::TYPE_LEAF_ASSERT) {
                $result = $this;
            }
        } else if ($this->type == qtype_preg_node::TYPE_LEAF_ASSERT && ($other->type ==qtype_preg_node::TYPE_LEAF_ASSERT ||
                    $other->type == qtype_preg_node::TYPE_LEAF_META && $other->subtype == qtype_preg_leaf_meta::SUBTYPE_EMPTY)) {
            $result = $this;
        }
        return $result;
    }

    /**
     * Returns label of leaf.
     *
     */
    public function leaf_tohr() {
        return $this->tohr();
    }

    /**
     * Returns the number of characters consumed by this leaf: 0 in case of an assertion or eps-leaf,
     * 1 in case of a single character, n in case of a backreferense.
     * @param matcherstateobj an object which implements qtype_preg_matcher_state interface.
     * @return number of characters consumed by this leaf.
     */
    public function consumes($matcherstateobj = null) {
        return 1;
    }

    /**
     * Returns true if character(s) starting from $str[$pos] match(es) this leaf, false otherwise
     * @param str the string being matched.
     * @param pos position of character in the string, if leaf is non-consuming than position before this character is analyzed.
     * @param length an integer variable to store the length of the match.
     * @param matcherstateobj an object which implements the qtype_preg_matcher_state interface.
     */
    abstract public function match($str, $pos, &$length, $matcherstateobj = null);

    /**
     * Returns an array (flag, character) suitable for both this leaf and merged assertions and the previous character.
     * @param originalstr original string passed to the matcher
     * @param newstr string (being) generated so far
     * @param pos index where the generated character will be placed.
     * @param length number of characters matched (can be greater than 0 in case of a partial backreference match).
     * @param matcherstateobj an object which implements the qtype_preg_matcher_state interface.
     */
    abstract public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null);

    /**
     * Returns a human-readable form of this leaf.
     * @return human-readable string describing this leaf.
     */
    public function tohr() {
        $cur = '';

        foreach ($this->userinscription as $inscrip) {
            if (is_array($inscrip)) {
                foreach ($inscrip as $in => $interpart) {
                    foreach ($interpart as $character) {
                        if (is_array($character)) {
                            $this->userinscription = array($character);
                            $cur = $this->tohr();
                            break;
                        } else {
                            $cur .= $character->data;
                        }
                    }
                    if ($in != count($inscrip) - 1 && $cur != '') {
                        $cur .= ' ∩ ';
                    }
                }
            } else {
                $cur .= $inscrip->data;
            }
        }
        return $cur;
    }

    public function find_all_subtrees($node, $numberoffset) {
        if ($this->is_equal($node, $numberoffset)) {
            return array($this);
        } else {
            return array();
        }
    }
}

/**
 * Defines operator nodes.
 */
abstract class qtype_preg_operator extends qtype_preg_node {

    /** An array of operands. */
    public $operands = array();

    public function __clone() {
        parent::__clone();
        // When clonning an operator we also want its subtree to be cloned.
        foreach ($this->operands as $i => $operand) {
            $this->operands[$i] = clone $operand;
        }
    }

    public function calculate_nflf(&$followpos) {
        // Calculate nflf for all operands.
        foreach ($this->operands as $operand) {
            $operand->calculate_nflf($followpos);
        }
        if (count($this->operands) > 0) {
            $this->nullable = $this->operands[0]->nullable;
            $this->firstpos = $this->operands[0]->firstpos;
            $this->lastpos = $this->operands[0]->lastpos;
        } else {
            $this->nullable = false;
            $this->firstpos = array();
            $this->lastpos = array();
        }
    }

    /**
     * N-ary concatenation and alternation can be expanded, but templates can not.
     */
    public function is_expandable() {
        return true;
    }

    public function expand($from, $to, &$idcounter, $expandsubtree = false) {
        if ($expandsubtree) {
            for ($i = $from; $i <= $to; $i++) {
                $this->operands[$i]->expand_all($idcounter, $expandsubtree);
            }
        }

        if (count($this->operands) <= 2) {
            return;
        }

        $operands = array();

        // Copy 'left' operands.
        for ($i = 0; $i < $from; $i++) {
            $operands[] = $this->operands[$i];
        }

        // Form the new subtree and add it as operand.
        $newnode = clone $this; // Will go down the tree.
        $newnode->id = ++$idcounter;
        $newnode->operands = array();
        for ($i = $from; $i <= $to; $i++) {
            $newnode->operands[] = $this->operands[$i];
        }
        $operands[] = $newnode;

        // Copy 'right' operands.
        for ($i = $to + 1; $i < count($this->operands); $i++) {
            $operands[] = $this->operands[$i];
        }

        // Update operands of this node.
        $this->operands = $operands;
        if ($expandsubtree) {
        	$newnode->expand(0, count($newnode->operands) - 2, $idcounter);
        }

        // Fix the new node position.
        $left = $newnode->operands[0];
        $right = $newnode->operands[count($newnode->operands) - 1];
        $newnode->position = new qtype_preg_position($left->position->indfirst, $right->position->indlast,
                                                     $left->position->linefirst, $right->position->linelast,
                                                     $left->position->colfirst, $right->position->collast);

        if (count($operands) == 1) {
            $this->operands = $newnode->operands;
        }
    }

    public function expand_all(&$idcounter, $expandsubtree = false) {
        $this->expand(0, count($this->operands) - 1, $idcounter, $expandsubtree);
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset) && $this->is_operands_equal($node, $numberoffset);
    }

    public function is_operands_equal($node, $numberoffset) {
        $operands_arr1 = $this->operands;
        $operands_arr2 = $node->operands;
        if (count($operands_arr1) !== count($operands_arr2)) {
            return false;
        } else {
            $result = true;
            foreach ($operands_arr1 as $index => $operands1) {
                $inner_result = $operands1->is_equal($operands_arr2[$index], $numberoffset);
                $result = $result && $inner_result;
                if ($result === false) break;
            }
            return $result;
        }
    }

    public function find_all_subtrees($node, $numberoffset) {
        $result = array();
        if ($this->is_equal($node, $numberoffset)) {
            array_push($result, $this);
        }
        foreach ($this->operands as $operand) {
            $isinsubexpr = $operand->type === qtype_preg_node::TYPE_NODE_SUBEXPR
                && $operand->subtype === qtype_preg_node_subexpr::SUBTYPE_SUBEXPR;
            $nextnumberoffset = $isinsubexpr ? $operand->number-1 : $numberoffset;
            $result = array_merge($result, $operand->find_all_subtrees($node, $nextnumberoffset));
        }
        return $result;
    }
}

/**
 * Represents a character or a charcter set.
 */
class qtype_preg_leaf_charset extends qtype_preg_leaf {

    /** Simple flags in the disjunctive normal form. */
    public $flags = null;   // array(array());
    /** A range is a pair of integers, ranges are 3-dimensional array of integers or 2-dimensional array of pairs. */
    protected $ranges = array();

    protected $cachedranges = null;

    public function __construct() {
        $this->type = qtype_preg_node::TYPE_LEAF_CHARSET;
    }

    public function __clone() {
        parent::__clone();
        if ($this->flags !== null) {
            foreach ($this->flags as $ind1 => $extflag) {
                $cur = array();
                foreach ($extflag as $ind2 => $inflag) {
                    $cur[$ind2] = clone $inflag;
                }
                $this->flags[$ind1] = $cur;
            }
        }
    }

    public function clear_cached_ranges() {
        $this->cachedranges = null;
    }

    public function is_single_character() {
        return count($this->flags) == 1 &&
               $this->flags[0][0]->type == qtype_preg_charset_flag::TYPE_SET &&
               $this->flags[0][0]->data->length() == 1;
    }

    public function is_single_printable_character() {
        if (!$this->is_single_character()) {
            return false;
        }
        return !qtype_preg_unicode::is_in_range($this->flags[0][0]->data[0], qtype_preg_unicode::Z_ranges()) &&
               !qtype_preg_unicode::is_in_range($this->flags[0][0]->data[0], qtype_preg_unicode::C_ranges());
    }

    public function is_single_non_printable_character() {
        if (!$this->is_single_character()) {
            return false;
        }
        return qtype_preg_unicode::is_in_range($this->flags[0][0]->data[0], qtype_preg_unicode::Z_ranges()) ||
               qtype_preg_unicode::is_in_range($this->flags[0][0]->data[0], qtype_preg_unicode::C_ranges());
    }

    /**
     * Checks if it's a single \a \b \e \f \r \t
     */
    public function is_single_escape_sequence_character() {
        if (!$this->is_single_character()) {
            return false;
        }
        return in_array($this->userinscription[0]->data, qtype_preg_lexer::char_escape_sequences_inside_charset());
    }

    public function is_single_flag() {
        return count($this->flags) == 1 &&
               $this->flags[0][0]->type == qtype_preg_charset_flag::TYPE_FLAG &&
               $this->flags[0][0]->data != qtype_preg_charset_flag::META_DOT;
    }

    public function is_single_dot() {
        return count($this->flags) == 1 &&
               $this->flags[0][0]->type == qtype_preg_charset_flag::TYPE_FLAG &&
               $this->flags[0][0]->data == qtype_preg_charset_flag::META_DOT;
    }

    public function ranges() {
        if ($this->cachedranges !== null) {
            return $this->cachedranges;
        }

        for ($i = 0; $i < count($this->flags); ++$i) {
            // Get the intersection for current disjunct
            $tmp = $this->flags[$i][0]->ranges($this->caseless);
            for ($j = 1; $j < count($this->flags[$i]); ++$j) {
                $ranges = $this->flags[$i][$j]->ranges($this->caseless);
                $tmp = qtype_preg_unicode::kinda_operator($tmp, $ranges, true, false, false, false);
            }

            // Add it to the result
            $this->cachedranges = $i == 0
                                ? $tmp
                                : qtype_preg_unicode::kinda_operator($this->cachedranges, $tmp, true, true, true, false);
        }

        if ($this->negative) {
            $this->cachedranges = qtype_preg_unicode::negate_ranges($this->cachedranges);
        }

        return $this->cachedranges;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        if ($pos < 0 || $pos >= $str->length()) {
            return false;
        }
        if ($this->flags === null) {
            return false;
        }

        $ranges = $this->ranges();
        $char = $str[$pos];
        if ($this->caseless) {
            $charlower = core_text::strtolower($char);
            $charupper = core_text::strtoupper($char);
            $result = qtype_preg_unicode::is_in_range($charlower, $ranges) || qtype_preg_unicode::is_in_range($charupper, $ranges);
        } else {
            $result = qtype_preg_unicode::is_in_range($char, $ranges);
        }
        $length = $result ? 1 : 0;
        return $result;
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        $ranges = $this->ranges();

        if (empty($ranges)) {
        	return array(self::NEXT_CHAR_CANNOT_GENERATE, null);
        }

        return array(self::NEXT_CHAR_OK, new qtype_poasquestion\string(qtype_preg_unicode::code2utf8($ranges[0][0])));
    }

    /*public function tohr() {
        $result = '';
        foreach ($this->flags as $ind1 => $extflag) {
            $cur = '';
            foreach ($extflag as $ind2 => $inflag) {
                $cur .= $inflag->tohr();
                if ($ind2 != count($extflag) - 1) {
                    $cur .= '&&';
                }
            }
            $result .= $cur;
            if ($ind1 != count($this->flags) - 1) {
                $result .= ' || ';
            }
        }
        return $result;
    }*/

    /**
     * Intersects this charset with other one.
     * @param other charset to intersect with.
     * @return an object of qtype_preg_leaf_charset which is the intersection of this and other.
     */
    public function intersect(qtype_preg_leaf_charset $other) {
        if ($this->negative) {
            $this->push_negative();
        }
        if ($other->negative) {
            $other->push_negative();
        }
        foreach ($this->flags as $disjunct1) {
            foreach ($other->flags as $disjunct2) {
                $resflags[] = array_merge($disjunct1, $disjunct2);
            }
        }
        $result = new qtype_preg_leaf_charset;
        $result->flags = $resflags;
        if ($this->position !== null && $other->position !== null) {
            $position = $this->position->compose($other->position);
        } else if ($this->position !== null) {
            $position = $this->position;
        } else if ($other->position !== null) {
            $position = $other->position;
        } else {
            $position = new qtype_preg_position();
        }
        $result->set_user_info($position, array(array(0 => $this->userinscription, 1 => $other->userinscription)));

        return $result;
    }

    /**
     * Intersects this charset with another one using ranges for analysis success of intersection.
     * @param other charset to intersect with.
     * @return an object of qtype_preg_leaf_charset which is the intersection of this and other.
     */
    public function intersect_with_ranges(qtype_preg_leaf_charset $other) {
        $ranges = array();
        $resrange = array();
        $neg = array();
        $charset = $this->intersect($other);
        foreach ($charset->flags as $flags) {
            foreach ($flags as $flag) {
                switch ($flag->type) {
                    case qtype_preg_charset_flag::TYPE_SET:
                        $ranges[] = qtype_preg_unicode::get_ranges_from_charset($flag->data, $this->caseless);
                        $neg[] = $flag->negative;
                        break;
                    case qtype_preg_charset_flag::TYPE_FLAG:
                        $ranges[] = call_user_func('qtype_preg_unicode::' . $flag->data . '_ranges');
                        $neg[] = $flag->negative;
                        break;
                }
            }
        }
        if (count($ranges) >= 2) {
            $xy = !$neg[0] && !$neg[1];
            $xny = !$neg[0] && $neg[1];
            $nxy = $neg[0] && !$neg[1];
            $nxny = $neg[0] && $neg[1];
            $resrange = qtype_preg_unicode::kinda_operator($ranges[0], $ranges[1], $xy, $xny, $nxy, $nxny);
            for ($i = 2; $i < count($ranges); $i++) {
                $resrange = qtype_preg_unicode::kinda_operator($resrange, $ranges[$i], !$neg[$i], $neg[$i], false, false);
            }
        }
        if (count($resrange) == 0) {
            $charset = null;
        }
        return $charset;
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset) && ($this->ranges() == $node->ranges());
    }
}

/**
 * Represents a part of a charset - can be a numerable characters, flag like \w, \d or a unicode property.
 */
class qtype_preg_charset_flag {

    // Charset types.
    const TYPE_SET               = 'enumerable_characters';
    const TYPE_FLAG              = 'functionally_calculated_characters';

    const META_DOT               = 'dot';

    // Escape sequences.
    const SLASH_D                = 'slashd';
    const SLASH_H                = 'slashh';
    const SLASH_S                = 'slashs';
    const SLASH_V                = 'slashv';
    const SLASH_W                = 'slashw';

    // POSIX classes.
    const POSIX_ALNUM            = 'alnum';      // [:alnum:]
    const POSIX_ALPHA            = 'alpha';      // [:alpha:]
    const POSIX_ASCII            = 'ascii';      // [:ascii:]
    const POSIX_BLANK            = 'blank';      // [:blank:]
    const POSIX_CNTRL            = 'cntrl';      // [:cntrl:]
    const POSIX_DIGIT            = 'digit';      // [:digit:]
    const POSIX_GRAPH            = 'graph';      // [:graph:]
    const POSIX_LOWER            = 'lower';      // [:lower:]
    const POSIX_PRINT            = 'print';      // [:print:]
    const POSIX_PUNCT            = 'punct';      // [:punct:]
    const POSIX_SPACE            = 'space';      // [:space:]
    const POSIX_UPPER            = 'upper';      // [:upper:]
    const POSIX_WORD             = 'word';       // [:word:]
    const POSIX_XDIGIT           = 'xdigit';     // [:xdigit:]

    const UPROP_C                 = 'C';          // Other
    const UPROP_Cc                = 'Cc';         // Control
    const UPROP_Cf                = 'Cf';         // Format
    const UPROP_Cn                = 'Cn';         // Unassigned
    const UPROP_Co                = 'Co';         // Private use
    const UPROP_Cs                = 'Cs';         // Surrogate

    const UPROP_L                 = 'L';          // Letter
    const UPROP_Ll                = 'Ll';         // Lower case letter
    const UPROP_Lm                = 'Lm';         // Modifier letter
    const UPROP_Lo                = 'Lo';         // Other letter
    const UPROP_Lt                = 'Lt';         // Title case letter
    const UPROP_Lu                = 'Lu';         // Upper case letter
    const UPROP_Llut              = 'Llut';       // Ll, Lu, or Lt

    const UPROP_M                 = 'M';          // Mark
    const UPROP_Mc                = 'Mc';         // Spacing mark
    const UPROP_Me                = 'Me';         // Enclosing mark
    const UPROP_Mn                = 'Mn';         // Non-spacing mark

    const UPROP_N                 = 'N';          // Number
    const UPROP_Nd                = 'Nd';         // Decimal number
    const UPROP_Nl                = 'Nl';         // Letter number
    const UPROP_No                = 'No';         // Other number

    const UPROP_P                 = 'P';          // Punctuation
    const UPROP_Pc                = 'Pc';         // Connector punctuation
    const UPROP_Pd                = 'Pd';         // Dash punctuation
    const UPROP_Pe                = 'Pe';         // Close punctuation
    const UPROP_Pf                = 'Pf';         // Final punctuation
    const UPROP_Pi                = 'Pi';         // Initial punctuation
    const UPROP_Po                = 'Po';         // Other punctuation
    const UPROP_Ps                = 'Ps';         // Open punctuation

    const UPROP_S                 = 'S';          // Symbol
    const UPROP_Sc                = 'Sc';         // Currency symbol
    const UPROP_Sk                = 'Sk';         // Modifier symbol
    const UPROP_Sm                = 'Sm';         // Mathematical symbol
    const UPROP_So                = 'So';         // Other symbol

    const UPROP_Z                 = 'Z';          // Separator
    const UPROP_Zl                = 'Zl';         // Line separator
    const UPROP_Zp                = 'Zp';         // Paragraph separator
    const UPROP_Zs                = 'Zs';         // Space separator

    const UPROP_Xan               = 'Xan';        // Alphanumeric: union of properties L and N
    const UPROP_Xps               = 'Xps';        // POSIX space: property Z or tab, NL, VT, FF, CR
    const UPROP_Xsp               = 'Xsp';        // Perl space: property Z or tab, NL, VT, FF, CR
    const UPROP_Xuc               = 'Xuc';        // Univerally-named character: one that can be represented by a Universal Character Name
    const UPROP_Xwd               = 'Xwd';        // Perl word: property Xan or underscore

    const UPROP_Arabic                 = 'Arabic';
    const UPROP_Armenian               = 'Armenian';
    const UPROP_Avestan                = 'Avestan';
    const UPROP_Balinese               = 'Balinese';
    const UPROP_Batak                  = 'Batak';
    const UPROP_Bamum                  = 'Bamum';
    const UPROP_Bengali                = 'Bengali';
    const UPROP_Bopomofo               = 'Bopomofo';
    const UPROP_Brahmi                 = 'Brahmi';
    const UPROP_Braille                = 'Braille';
    const UPROP_Buginese               = 'Buginese';
    const UPROP_Buhid                  = 'Buhid';
    const UPROP_Canadian_Aboriginal    = 'Canadian_Aboriginal';
    const UPROP_Carian                 = 'Carian';
    const UPROP_Chakma                 = 'Chakma';
    const UPROP_Cham                   = 'Cham';
    const UPROP_Cherokee               = 'Cherokee';
    const UPROP_Common                 = 'Common';
    const UPROP_Coptic                 = 'Coptic';
    const UPROP_Cuneiform              = 'Cuneiform';
    const UPROP_Cypriot                = 'Cypriot';
    const UPROP_Cyrillic               = 'Cyrillic';
    const UPROP_Deseret                = 'Deseret';
    const UPROP_Devanagari             = 'Devanagari';
    const UPROP_Egyptian_Hieroglyphs   = 'Egyptian_Hieroglyphs';
    const UPROP_Ethiopic               = 'Ethiopic';
    const UPROP_Georgian               = 'Georgian';
    const UPROP_Glagolitic             = 'Glagolitic';
    const UPROP_Gothic                 = 'Gothic';
    const UPROP_Greek                  = 'Greek';
    const UPROP_Gujarati               = 'Gujarati';
    const UPROP_Gurmukhi               = 'Gurmukhi';
    const UPROP_Han                    = 'Han';
    const UPROP_Hangul                 = 'Hangul';
    const UPROP_Hanunoo                = 'Hanunoo';
    const UPROP_Hebrew                 = 'Hebrew';
    const UPROP_Hiragana               = 'Hiragana';
    const UPROP_Imperial_Aramaic       = 'Imperial_Aramaic';
    const UPROP_Inherited              = 'Inherited';
    const UPROP_Inscriptional_Pahlavi  = 'Inscriptional_Pahlavi';
    const UPROP_Inscriptional_Parthian = 'Inscriptional_Parthian';
    const UPROP_Javanese               = 'Javanese';
    const UPROP_Kaithi                 = 'Kaithi';
    const UPROP_Kannada                = 'Kannada';
    const UPROP_Katakana               = 'Katakana';
    const UPROP_Kayah_Li               = 'Kayah_Li';
    const UPROP_Kharoshthi             = 'Kharoshthi';
    const UPROP_Khmer                  = 'Khmer';
    const UPROP_Lao                    = 'Lao';
    const UPROP_Latin                  = 'Latin';
    const UPROP_Lepcha                 = 'Lepcha';
    const UPROP_Limbu                  = 'Limbu';
    const UPROP_Linear_B               = 'Linear_B';
    const UPROP_Lisu                   = 'Lisu';
    const UPROP_Lycian                 = 'Lycian';
    const UPROP_Lydian                 = 'Lydian';
    const UPROP_Malayalam              = 'Malayalam';
    const UPROP_Mandaic                = 'Mandaic';
    const UPROP_Meetei_Mayek           = 'Meetei_Mayek';
    const UPROP_Meroitic_Cursive       = 'Meroitic_Cursive';
    const UPROP_Meroitic_Hieroglyphs   = 'Meroitic_Hieroglyphs';
    const UPROP_Miao                   = 'Miao';
    const UPROP_Mongolian              = 'Mongolian';
    const UPROP_Myanmar                = 'Myanmar';
    const UPROP_New_Tai_Lue            = 'New_Tai_Lue';
    const UPROP_Nko                    = 'Nko';
    const UPROP_Ogham                  = 'Ogham';
    const UPROP_Old_Italic             = 'Old_Italic';
    const UPROP_Old_Persian            = 'Old_Persian';
    const UPROP_Old_South_Arabian      = 'Old_South_Arabian';
    const UPROP_Old_Turkic             = 'Old_Turkic';
    const UPROP_Ol_Chiki               = 'Ol_Chiki';
    const UPROP_Oriya                  = 'Oriya';
    const UPROP_Osmanya                = 'Osmanya';
    const UPROP_Phags_Pa               = 'Phags_Pa';
    const UPROP_Phoenician             = 'Phoenician';
    const UPROP_Rejang                 = 'Rejang';
    const UPROP_Runic                  = 'Runic';
    const UPROP_Samaritan              = 'Samaritan';
    const UPROP_Saurashtra             = 'Saurashtra';
    const UPROP_Sharada                = 'Sharada';
    const UPROP_Shavian                = 'Shavian';
    const UPROP_Sinhala                = 'Sinhala';
    const UPROP_Sora_Sompeng           = 'Sora_Sompeng';
    const UPROP_Sundanese              = 'Sundanese';
    const UPROP_Syloti_Nagri           = 'Syloti_Nagri';
    const UPROP_Syriac                 = 'Syriac';
    const UPROP_Tagalog                = 'Tagalog';
    const UPROP_Tagbanwa               = 'Tagbanwa';
    const UPROP_Tai_Le                 = 'Tai_Le';
    const UPROP_Tai_Tham               = 'Tai_Tham';
    const UPROP_Tai_Viet               = 'Tai_Viet';
    const UPROP_Takri                  = 'Takri';
    const UPROP_Tamil                  = 'Tamil';
    const UPROP_Telugu                 = 'Telugu';
    const UPROP_Thaana                 = 'Thaana';
    const UPROP_Thai                   = 'Thai';
    const UPROP_Tibetan                = 'Tibetan';
    const UPROP_Tifinagh               = 'Tifinagh';
    const UPROP_Ugaritic               = 'Ugaritic';
    const UPROP_Vai                    = 'Vai';
    const UPROP_Yi                     = 'Yi';

    /** Is this flag negative? */
    public $negative = false;
    /** Type of this flag, can be either TYPE_SET or TYPE_FLAG. */
    public $type;
    /** Characters, flag or unicode property if this is a TYPE_SET, TYPE_FLAG correspondingly. */
    public $data;

    private $cachedranges = null;


    public function __clone() {
        if (is_object($this->data)) {
            $this->data = clone $this->data;
        }
    }

    /**
     * Sets the subtype and the data of this flag.
     * @param type a constant defining the subtype of this flag.
     * @param data the concrete value of this flag - characters, a flag or a unicode property.
     */
    public function set_data($type, $data) {
        $this->type = $type;
        $this->data = $data;
    }

    public function ranges($caseless) {
        if ($this->cachedranges === null) {
            switch ($this->type) {
                case self::TYPE_SET:
                    $this->cachedranges = qtype_preg_unicode::get_ranges_from_charset($this->data, $caseless);
                    break;
                case self::TYPE_FLAG:
                    $this->cachedranges = call_user_func('qtype_preg_unicode::' . $this->data . '_ranges');
                    break;
            }
            if ($this->negative) {
                $this->cachedranges = qtype_preg_unicode::negate_ranges($this->cachedranges);
            }
        }
        return $this->cachedranges;
    }

    public function tohr() {
        $result = '';
        switch ($this->type) {
            case self::TYPE_SET:
                $result = $this->data;
                break;
            case self::TYPE_FLAG:
                $result = $this->data;
                break;
            case self::META_DOT:
                $result = '.';
                break;
            default:
                return '';
        }
        if ($this->negative) {
            $result = '!' . $result;
        }
        return $result;
    }
}

/**
 * Defines meta-characters that can't be enumerated.
 */
class qtype_preg_leaf_meta extends qtype_preg_leaf {

    // Leaf with empty in alternation (something|).
    const SUBTYPE_EMPTY = 'empty_leaf_meta';

    public function __construct($subtype = null) {
        $this->type = qtype_preg_node::TYPE_LEAF_META;
        $this->subtype = $subtype;
    }

    public function calculate_nflf(&$followpos) {
        parent::calculate_nflf($followpos);
        if ($this->subtype == self::SUBTYPE_EMPTY) {
            $this->nullable = true;
            $this->firstpos = array();
            $this->lastpos = array();
        }
    }

    // TODO - ui_nodename().

    public function consumes($matcherstateobj = null) {
        return 0;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        $length = 0;
        return true;
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        return array(self::NEXT_CHAR_OK, new qtype_poasquestion\string(''));
    }

    public function tohr() {
        return 'ε';
    }

}

class qtype_preg_leaf_complex_assert extends qtype_preg_leaf_meta {

    const SUBTYPE_LOOKAHEAD = 'lookahead_leaf_complex_assert';
    const SUBTYPE_LOOKBEHIND = 'lookbehind_leaf_complex_assert';

    public $innerautomaton;

    public function __construct($subtype, $innerautomaton) {
        $this->type = qtype_preg_node::TYPE_LEAF_COMPLEX_ASSERT;
        $this->subtype = $subtype;
        $this->innerautomaton = $innerautomaton;
    }
}

/**
 * Base class for simple assertions.
 */
abstract class qtype_preg_leaf_assert extends qtype_preg_leaf {

    /** \b and \B */
    const SUBTYPE_ESC_B = 'esc_b_leaf_assert';
    /** \A */
    const SUBTYPE_ESC_A = 'esc_a_leaf_assert';
    /** \z */
    const SUBTYPE_SMALL_ESC_Z = 'small_esc_z_leaf_assert';
    /** \Z */
    const SUBTYPE_CAPITAL_ESC_Z = 'capital_esc_z_leaf_assert';
    /** \G */
    const SUBTYPE_ESC_G = 'esc_g_leaf_assert';
    /** ^ */
    const SUBTYPE_CIRCUMFLEX = 'circumflex_leaf_assert';
    /** $ */
    const SUBTYPE_DOLLAR = 'dollar_leaf_assert';
    /** Assertion used by conditional subexpressions */
    const SUBTYPE_SUBEXPR = 'subexpr_leaf_assert';
    /** Assertion used by conditional subexpressions */
    const SUBTYPE_RECURSION = 'recursion_leaf_assert';
    /** Assertion that always true or false */
    const SUBTYPE_TRUEFALSE = 'truefalse_leaf_assert';

    public function __construct($negative = false) {
        $this->type = qtype_preg_node::TYPE_LEAF_ASSERT;
        $this->negative = $negative;
    }

    public function is_start_anchor() {
        return $this->subtype === self::SUBTYPE_CIRCUMFLEX || $this->subtype === self::SUBTYPE_ESC_A || $this->subtype === self::SUBTYPE_ESC_G;
    }

    public function is_end_anchor() {
        return $this->subtype === self::SUBTYPE_DOLLAR || $this->subtype === self::SUBTYPE_CAPITAL_ESC_Z || $this->subtype === self::SUBTYPE_SMALL_ESC_Z;
    }

    /**
     * By an artificial assert we imply one that can not be written by user.
     */
    public function is_artificial_assert() {
        return $this->subtype === self::SUBTYPE_SUBEXPR || $this->subtype === self::SUBTYPE_RECURSION || $this->subtype === self::SUBTYPE_TRUEFALSE;
    }

    public function consumes($matcherstateobj = null) {
        return 0;
    }
}

/**
 * Simple assertion \B (negative == true) matches at not a word boundary.
 * Simple assertion \b (negative == false) matches at a word boundary.
 */
class qtype_preg_leaf_assert_esc_b extends qtype_preg_leaf_assert {

    public function __construct($negative = false) {
        parent::__construct($negative);
        $this->subtype = self::SUBTYPE_ESC_B;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        $alnumrange = qtype_preg_unicode::alnum_ranges();
        $ch0 = $str[0];
        $ch1 = $str[$pos - 1];

        $flag0 = $ch0 == '_' || qtype_preg_unicode::is_in_range($ch0, $alnumrange);
        $flag1 = $ch1 == '_' || qtype_preg_unicode::is_in_range($ch1, $alnumrange);

        $start = $flag0 && $pos == 0;
        $end = $flag1 && $pos == $str->length();
        $wnotw = false;
        $notww = false;

        if ($pos > 0 && $pos < $str->length()) {
            $ch2 = $str[$pos];
            $flag2 = $ch2 == '_' || qtype_preg_unicode::is_in_range($ch2, $alnumrange);
            $wnotw = $flag1 && !$flag2;
            $notww = !$flag1 && $flag2;
        }

        $length = 0;
        return (($start || $end || $wnotw || $notww) xor $this->negative);
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        return array(self::NEXT_CHAR_OK, new qtype_poasquestion\string(''));  // TODO
    }

    public function tohr() {
        return $this->negative ? '\B' : '\b';
    }
}

/**
 * Simple assertion \A matches at the very start of the string.
 */
class qtype_preg_leaf_assert_esc_a extends qtype_preg_leaf_assert {

    public function __construct() {
        parent::__construct();
        $this->subtype = self::SUBTYPE_ESC_A;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        $length = 0;
        return ($pos == 0);
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        if ($pos == 0) {
            return array(self::NEXT_CHAR_OK, new qtype_poasquestion\string(''));
        }
        return array(self::NEXT_CHAR_CANNOT_GENERATE, null);
    }

    public function tohr() {
        return '\A';
    }
}

/**
 * Simple assertion \z matches only at the end of the string.
 */
class qtype_preg_leaf_assert_small_esc_z extends qtype_preg_leaf_assert {

    public function __construct() {
        parent::__construct();
        $this->subtype = self::SUBTYPE_SMALL_ESC_Z;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        $length = 0;
        return ($pos == $str->length());
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        return array(self::NEXT_CHAR_END_HERE, null);
    }

    public function tohr() {
        return '\z';
    }
}

/**
 * Simple assertion \Z matches at the end of the string, also matches before the very last newline.
 */
class qtype_preg_leaf_assert_capital_esc_z extends qtype_preg_leaf_assert_small_esc_z {

    public function __construct() {
        parent::__construct();
        $this->subtype = self::SUBTYPE_CAPITAL_ESC_Z;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        return ($pos == $str->length() - 1 && $str[$pos] == "\n") || parent::match($str, $pos, $length, $matcherstateobj);
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        return array(self::NEXT_CHAR_END_HERE, null);
    }

    public function tohr() {
        return '\Z';
    }
}

class qtype_preg_leaf_assert_esc_g extends qtype_preg_leaf_assert {

    public function __construct() {
        parent::__construct();
        $this->subtype = self::SUBTYPE_ESC_G;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        $length = 0;
        return $pos === $matcherstateobj->start_pos();
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        if ($pos == $matcherstateobj->start_pos()) {
            return array(self::NEXT_CHAR_OK, new qtype_poasquestion\string(''));
        }
        return array(self::NEXT_CHAR_CANNOT_GENERATE, null);
    }

    public function tohr() {
        return '\G';
    }
}

/**
 * Simple assertion ^ matches at the very start of the string or after any \n.
 * Used only in multiline mode.
 */
class qtype_preg_leaf_assert_circumflex extends qtype_preg_leaf_assert_esc_a {

    public function __construct() {
        parent::__construct();
        $this->subtype = self::SUBTYPE_CIRCUMFLEX;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        return ($str[$pos - 1] == "\n") || parent::match($str, $pos, $length, $matcherstateobj);
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        if ($pos == 0 || $newstr[$pos - 1] == "\n") {
            return array(self::NEXT_CHAR_OK, new qtype_poasquestion\string(''));
        }
        return array(self::NEXT_CHAR_CANNOT_GENERATE, null);
    }

    public function tohr() {
        return '^';
    }
}

/**
 * Simple assertion $ matches at the end of the string and before any \n.
 * Used only in multiline mode.
 */
class qtype_preg_leaf_assert_dollar extends qtype_preg_leaf_assert_capital_esc_z {

    public function __construct() {
        parent::__construct();
        $this->subtype = self::SUBTYPE_DOLLAR;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        return ($str[$pos] == "\n") || parent::match($str, $pos, $length, $matcherstateobj);
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        return array(self::NEXT_CHAR_END_HERE, null);
    }

    public function tohr() {
        return '$';
    }
}

/**
 * Assertion that checks if a subexpression is captured.
 */
class qtype_preg_leaf_assert_subexpr extends qtype_preg_leaf_assert {

    /** Subexpression number to refer to. */
    public $number;
    /** Subexpression name to refer to. */
    public $name;

    public function __construct($negative, $number = null, $name = null) {
        parent::__construct($negative);
        $this->subtype = self::SUBTYPE_SUBEXPR;
        $this->number = $number;
        $this->name = $name;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        $subexpr = $this->name !== null ? $this->name : $this->number;
        $length = 0;
        return ($matcherstateobj->is_subexpr_captured($subexpr) xor $this->negative);
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        $subexpr = $this->name !== null ? $this->name : $this->number;
        $ok = ($matcherstateobj->is_subexpr_captured($subexpr) xor $this->negative);
        return $ok ? array(self::NEXT_CHAR_OK, new qtype_poasquestion\string(''))
                   : array(self::NEXT_CHAR_CANNOT_GENERATE, null);
    }

    public function tohr() {
        $subexpr = $this->name !== null ? $this->name : $this->number;
        return $this->negative ? '!(' . $subexpr . ')'
                               : '(' . $subexpr . ')';
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            /*&& $this->name==$node->name*/
            && (($this->number!==null)?($this->number - $numberoffset):null) === $node->number;
    }
}

/**
 * Assertion that checks if a recursive call is running
 */
class qtype_preg_leaf_assert_recursion extends qtype_preg_leaf_assert {

    /** Subexpression number to check. */
    public $number;
    /** Subexpression name to check. */
    public $name;

    public function __construct($negative, $number = null, $name = null) {
        parent::__construct($negative);
        $this->subtype = self::SUBTYPE_RECURSION;
        $this->number = $number;
        $this->name = $name;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        $subexpr = $this->name !== null ? $this->name : $this->number;
        $length = 0;
        return ($matcherstateobj->is_recursion($subexpr) xor $this->negative);
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        $subexpr = $this->name !== null ? $this->name : $this->number;
        $ok = ($matcherstateobj->is_recursion($subexpr) xor $this->negative);
        return $ok ? array(self::NEXT_CHAR_OK, new qtype_poasquestion\string(''))
                   : array(self::NEXT_CHAR_CANNOT_GENERATE, null);
    }

    public function tohr() {
        $subexpr = $this->name !== null ? $this->name : $this->number;
        return $this->negative ? '!(' . $subexpr . ')'
                               : '(' . $subexpr . ')';
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            /*$this->name==$node->name */
            && (($this->number!==null)?($this->number - $numberoffset):null) === $node->number;
    }
}

/**
 * Assertion that always true or false. Used to implement DEFINE conditional subexpressions.
 */
class qtype_preg_leaf_assert_truefalse extends qtype_preg_leaf_assert {

    public function __construct($negative) {
        parent::__construct($negative);
        $this->subtype = self::SUBTYPE_TRUEFALSE;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        $length = 0;
        return !$this->negative;
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        $ok = !$this->negative;
        return $ok ? array(self::NEXT_CHAR_OK, new qtype_poasquestion\string(''))
                   : array(self::NEXT_CHAR_CANNOT_GENERATE, null);
    }

    public function tohr() {
        return $this->negative ? '(false)'
                               : '(true)';
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset);
    }
}

/**
 * Defines backreferences.
 */
class qtype_preg_leaf_backref extends qtype_preg_leaf {

    /** Subexpression number to refer to. */
    public $number;
    /** Subexpression name to refer to. */
    public $name;

    public function __construct($number = null, $name = null) {
        $this->type = qtype_preg_node::TYPE_LEAF_BACKREF;
        $this->subtype = $this->type;
        $this->number = $number;
        $this->name = $name;
    }

    public function lang_key($usedescription = false) {
        $result = parent::lang_key($usedescription);
        if ($usedescription && $this->name !== null) {
            $result .= '_name';
        }
        return $result;
    }

    public function consumes($matcherstateobj = null) {
        if (!$matcherstateobj->is_subexpr_captured($this->number)) {
            return qtype_preg_matching_results::UNKNOWN_CHARACTERS_LEFT;
        }
        return $matcherstateobj->length($this->number);
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        $length = 0;
        $subexpr = $this->name !== null ? $this->name : $this->number;

        if (!$matcherstateobj->is_subexpr_captured($subexpr)) {
            // For no match return the result immediately.
            return false;
        }

        $subexprlen = $matcherstateobj->length($subexpr);
        if ($subexprlen == 0) {
            // For empty match return the result immediately.
            return true;
        }

        if ($pos >= $str->length()) {
            // Out of borders.
            return false;
        }

        $start = $matcherstateobj->index_first($subexpr);
        $end = $start + $subexprlen - 1;

        $strcopy = clone $str;
        if ($this->caseless) {
            $strcopy->tolower();
        }

        // Check char by char.
        $result = true;
        for ($i = $start; $result && $i <= $end && $length + $pos < $strcopy->length(); $i++) {
            $result = $result && ($strcopy[$i] == $strcopy[$pos + $length]);
            if ($result) {
                $length++;
            } else {
                break;
            }
        }

        // If the string has not enough characters.
        if ($pos + $subexprlen - 1 >= $strcopy->length()) {
            $result = false;
        }

        return $result;
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        $subexpr = $this->name !== null ? $this->name : $this->number;
        if (!$matcherstateobj->is_subexpr_captured($subexpr)) {
            return array(self::NEXT_CHAR_CANNOT_GENERATE, null);
        }
        $start = $matcherstateobj->index_first($subexpr);
        $end = $start + $matcherstateobj->length($subexpr);
        if ($end > $newstr->length()) {
            return array(self::NEXT_CHAR_CANNOT_GENERATE, null);
        }

        return array(self::NEXT_CHAR_OK, $newstr->substring($start + $length, $end - $start - $length));
    }

    public function tohr() {
        $subexpr = $this->name !== null ? $this->name : $this->number;
        return 'backref #' . $subexpr;
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            /*&& $this->name==$node->name*/
            && (($this->number!==null)?($this->number - $numberoffset):null) === $node->number;
    }
}

class qtype_preg_leaf_subexpr_call extends qtype_preg_leaf {

    /** Subexpression number to call. */
    public $number;
    /** Subexpression name to call. */
    public $name;
    /** Is this actually a recursive call? Calculated by parser. */
    public $isrecursive;

    public function __construct($number = null, $name = null) {
        $this->type = qtype_preg_node::TYPE_LEAF_SUBEXPR_CALL;
        $this->subtype = $this->type;
        $this->number = $number;
        $this->name = $name;
        $this->isrecursive = false;
    }

    public function lang_key($usedescription = false) {
        $result = parent::lang_key($usedescription);
        if ($usedescription && $this->number === 0) {
            $result .= '_all';
        } else if ($usedescription && $this->name !== null) {
            $result .= '_name';
        }
        return $result;
    }

    public function match($str, $pos, &$length, $matcherstateobj = null) {
        // Matchers should handle subexpr calls without this node
        $length = 0;
        return true;
    }

    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        return array(self::NEXT_CHAR_CANNOT_GENERATE, null);
    }

    public function tohr() {
        return 'subexpression call';
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            /*&& $this->name==$node->name*/
            && (($this->number!==null)?($this->number - $numberoffset):null) === $node->number;
    }
}

class qtype_preg_leaf_template extends qtype_preg_leaf {
    public $name;
    public function __construct($name = '') {
        $this->type = qtype_preg_node::TYPE_LEAF_TEMPLATE;
        $this->name = $name;
    }
    public function match($str, $pos, &$length, $matcherstateobj = null) {
        return false;
    }
    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        return array(self::NEXT_CHAR_CANNOT_GENERATE, null);
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            && $this->name==$node->name;
    }
}

/**
 * Reperesents backtracking control, newline convention etc sequences like (*...).
 */
class qtype_preg_leaf_control extends qtype_preg_leaf {

    /** (*ACCEPT) */
    const SUBTYPE_ACCEPT = 'accept_leaf_control';
    /** (*FAIL) */
    const SUBTYPE_FAIL = 'fail_leaf_control';
    /** (*MARK:NAME) */
    const SUBTYPE_MARK_NAME = 'mark_name_leaf_control';

    /** (*COMMIT) */
    const SUBTYPE_COMMIT = 'commit_leaf_control';
    /** (*PRUNE) */
    const SUBTYPE_PRUNE = 'prune_leaf_control';
    /** (*SKIP) */
    const SUBTYPE_SKIP = 'skip_leaf_control';
    /** (*SKIP:NAME) */
    const SUBTYPE_SKIP_NAME = 'skip_name_leaf_control';
    /** (*THEN) */
    const SUBTYPE_THEN = 'then_leaf_control';

    /** (*CR) */
    const SUBTYPE_CR = 'cr_leaf_control';
    /** (*LF) */
    const SUBTYPE_LF = 'lf_leaf_control';
    /** (*CRLF) */
    const SUBTYPE_CRLF = 'crlf_leaf_control';
    /** (*ANYCRLF) */
    const SUBTYPE_ANYCRLF = 'anycrlf_leaf_control';
    /** (*ANY) */
    const SUBTYPE_ANY = 'any_leaf_control';

    /** (*BSR_ANYCRLF) */
    const SUBTYPE_BSR_ANYCRLF = 'bsr_anycrlf_leaf_control';
    /** (*BSR_UNICODE) */
    const SUBTYPE_BSR_UNICODE = 'bsr_unicode_leaf_control';

    /** (*NO_START_OPT) */
    const SUBTYPE_NO_START_OPT = 'no_start_opt_leaf_control';
    /** (*UTF8) */
    const SUBTYPE_UTF8 = 'utf8_leaf_control';
    /** (*UTF16) */
    const SUBTYPE_UTF16 = 'utf16_leaf_control';
    /** (*UCP) */
    const SUBTYPE_UCP = 'ucp_leaf_control';

    public $name;

    public function __construct($subtype = null, $name = null) {
        $this->type = qtype_preg_node::TYPE_LEAF_CONTROL;
        $this->subtype = $subtype;
        $this->name = $name;
    }
    public function match($str, $pos, &$length, $matcherstateobj = null) {
        // Do nothing, the matching should be controlled by the matching engine.
    }
    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        // Do nothing, the matching should be controlled by the matching engine.
    }
    public function tohr() {
        return 'control';
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            && $this->name==$node->name;
    }
}

class qtype_preg_leaf_options extends qtype_preg_leaf {
    public $posopt;
    public $negopt;

    public function __construct($posopt = null, $negopt = null) {
        $this->type = qtype_preg_node::TYPE_LEAF_OPTIONS;
        $this->subtype = $this->type;
        $this->posopt = $posopt;
        $this->negopt = $negopt;
    }
    public function match($str, $pos, &$length, $matcherstateobj = null) {
        die ('TODO: implement abstract function match for qtype_preg_leaf_options class before use it!');
    }
    public function next_character($originalstr, $newstr, $pos, $length = 0, $matcherstateobj = null) {
        die ('TODO: implement abstract function character for qtype_preg_leaf_options class before use it!');
    }
    public function tohr() {
        $result = '(?';
        if (!empty($this->posopt)) {
            $result .= $this->posopt;
        }
        if (!empty($this->negopt)) {
            $result .= '-'.$this->negopt;
        }
        return $result.')';
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            && count(array_diff(str_split($this->posopt), str_split($node->posopt)))==0
            && count(array_diff(str_split($this->negopt), str_split($node->negopt)))==0;
    }
}

/**
 * Defines finite quantifiers with left and right borders, unary operator.
 * Possible errors: left border is greater than right one.
 */
class qtype_preg_node_finite_quant extends qtype_preg_operator {

    /** Is quantifier lazy? */
    public $lazy;
    /** Is quantifier greedy? */
    public $greedy;
    /** Is quantifier possessive? */
    public $possessive;
    /** Smallest possible repetition number. */
    public $leftborder;
    /** Biggest possible repetition number. */
    public $rightborder;

    public function __construct($leftborder = 0, $rightborder = 0, $lazy = false, $greedy = true, $possessive = false) {
        $this->type = qtype_preg_node::TYPE_NODE_FINITE_QUANT;
        $this->subtype = $this->type;
        $this->leftborder = $leftborder;
        $this->rightborder = $rightborder;
        $this->lazy = $lazy;
        $this->greedy = $greedy;
        $this->possessive = $possessive;
    }

    public function is_subpattern() {
        return true;    // Finite quantifier is a subpattern.
    }

    public function calculate_nflf(&$followpos) {
        parent::calculate_nflf($followpos);
        $this->nullable = $this->nullable || $this->leftborder == 0;
        // TODO - followpos for situations like {2,10}
    }

    public function lang_key($usedescription = false) {
        $result = parent::lang_key($usedescription);
        if ($usedescription) {
            if ($this->leftborder == 0) {
                $result .= '_0';
                if ($this->rightborder == 1) {
                    $result .= '1';
                }
            } else if ($this->leftborder == 1) {
                $result .= '_1';
            } else if ($this->leftborder == $this->rightborder) {
                $result .= '_strict';
            }
        }
        return $result;
    }

    public function lang_key_for_greediness() {
        if ($this->lazy) {
            return 'description_quant_lazy';
        }
        if ($this->possessive) {
            return 'description_quant_possessive';
        }
        return 'description_quant_greedy';
    }

    // TODO - ui_nodename().

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            && $this->lazy==$node->lazy
            && $this->greedy==$node->greedy
            && $this->possessive==$node->possessive
            && $this->leftborder==$node->leftborder
            && $this->rightborder==$node->rightborder;
    }
}

/**
 * Defines infinite quantifiers node with the left border only, unary operator.
 */
class qtype_preg_node_infinite_quant extends qtype_preg_operator {

    /** Is quantifier lazy? */
    public $lazy;
    /** Is quantifier greedy? */
    public $greedy;
    /** Is quantifier possessive? */
    public $possessive;
    /** Smallest possible repetition number. */
    public $leftborder;

    public function __construct($leftborder = 0, $lazy = false, $greedy = true, $possessive = false) {
        $this->type = qtype_preg_node::TYPE_NODE_INFINITE_QUANT;
        $this->subtype = $this->type;
        $this->leftborder = $leftborder;
        $this->lazy = $lazy;
        $this->greedy = $greedy;
        $this->possessive = $possessive;
    }

    public function is_subpattern() {
        return true;    // Infinite quantifier is a subpattern.
    }

    public function calculate_nflf(&$followpos) {
        parent::calculate_nflf($followpos);
        $this->nullable = $this->nullable || $this->leftborder == 0;
        /*foreach ($this->lastpos as $lastpos) {
            if (!isset($followpos[$lastpos])) {
                $followpos[$lastpos] = array();
            }
            foreach ($this->operands[0]->firstpos as $firstpos) {
                if (!in_array($firstpos, $followpos[$lastpos])) {
                    $followpos[$lastpos][] = $firstpos;
                }
            }
        }*/
    }

    public function lang_key($usedescription = false) {
        $result = parent::lang_key($usedescription);
        if ($usedescription) {
            $result = 'description_' . $this->subtype;
            if ($this->leftborder == 0) {
                $result .= '_0';
            } else if ($this->leftborder == 1) {
                $result .= '_1';
            }
        }
        return $result;
    }

    public function lang_key_for_greediness() {
        if ($this->lazy) {
            return 'description_quant_lazy';
        }
        if ($this->possessive) {
            return 'description_quant_possessive';
        }
        return 'description_quant_greedy';
    }

    // TODO - ui_nodename().

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
        && $this->lazy==$node->lazy
        && $this->greedy==$node->greedy
        && $this->possessive==$node->possessive
        && $this->leftborder==$node->leftborder;
    }
}

/**
 * Defines concatenation, n-ary operator.
 */
class qtype_preg_node_concat extends qtype_preg_operator {

    public function __construct() {
        $this->type = qtype_preg_node::TYPE_NODE_CONCAT;
        $this->subtype = $this->type;
    }

    public function is_subpattern() {
        return false;    // Concatenation is not a subpattern.
    }

    public function calculate_nflf(&$followpos) {
        parent::calculate_nflf($followpos);
        $this->nullable = true;
        $this->firstpos = array();
        $this->lastpos = array();
        $count = count($this->operands);
        // Nullable and firstpos are calculated as always.
        for ($i = 0; $i < $count; $i++) {
            $operand = $this->operands[$i];
            if ($i == 0 || $this->nullable) {
                $this->firstpos = array_merge($this->firstpos, $operand->firstpos);
            }
            if (!$operand->nullable) {
                $this->nullable = false;
            }
        }
        // Lastpos is calculated backwards.
        for ($i = $count - 1; $i >= 0; $i--) {
            $operand = $this->operands[$i];
            $this->lastpos = array_merge($this->lastpos, $operand->lastpos);
            if (!$operand->nullable) {
                break;
            }
        }

        // Followpos is calculated for each operand except the last one.
        /*$followpos_prev = array(); // followpos calculated on the previous step.
        for ($i = $count - 2; $i >= 0; $i--) {
            $left = $this->operands[$i];
            $right = $this->operands[$i + 1];
            $followpos_new = array(); // followpos calculated on this step.

            foreach ($left->lastpos as $lastpos) {
                if (!isset($followpos[$lastpos])) {
                    $followpos[$lastpos] = array();
                }
                if (!isset($followpos_new[$lastpos])) {
                    $followpos_new[$lastpos] = array();
                }

                foreach ($right->firstpos as $firstpos) {
                    if (!in_array($firstpos, $followpos[$lastpos])) {
                        $followpos[$lastpos][] = $firstpos;
                        $followpos_new[$lastpos][] = $firstpos;
                    }
                }

                // Right operand is not nullable; continue.
                if (!$right->nullable || $i == $count - 2) {
                    continue;
                }

                // Right operand is nullable. Copy its follopos to current node.
                foreach ($followpos_prev as $from => $to) {
                    if (!isset($followpos[$from])) {
                        $followpos[$from] = array();
                    }
                    foreach ($to as $tmp) {
                        if (!in_array($tmp, $followpos[$lastpos])) {
                            $followpos[$lastpos][] = $tmp;
                            $followpos_new[$lastpos][] = $tmp;
                        }
                    }
                }
            }
            $followpos_prev = $followpos_new;
        }*/
    }
}

/**
 * Defines alternation, n-ary operator.
 */
class qtype_preg_node_alt extends qtype_preg_operator {

    public function __construct() {
        $this->type = qtype_preg_node::TYPE_NODE_ALT;
        $this->subtype = $this->type;
    }

    public function is_subpattern() {
        return false;    // Alternation is not a subpattern.
    }

    public function calculate_nflf(&$followpos) {
        parent::calculate_nflf($followpos);
        $this->nullable = false;
        $this->firstpos = array();
        $this->lastpos = array();
        for ($i = 0; $i < count($this->operands); $i++) {
            $operand = $this->operands[$i];
            if ($operand->nullable) {
                $this->nullable = true;
            }
            $this->firstpos = array_merge($this->firstpos, $operand->firstpos);
            $this->lastpos = array_merge($this->lastpos, $operand->lastpos);
        }
    }

    public function is_equal($node, $numberoffset) {
        return qtype_preg_node::is_equal($node, $numberoffset)
            && $this->is_operands_equal($node, $numberoffset);
    }

    public function is_operands_equal($node, $numberoffset) { // TODO - check we are not in n-arn mode
        $operands_arr1 = $this->operands;
        $operands_arr2 = $node->operands;
        if (count($operands_arr1) !== count($operands_arr2)) {
            return false;
        } else {
            $result = true;
            foreach ($operands_arr1 as $operands1) {
                $inner_result = false;
                foreach ($operands_arr2 as $operands2) {
                    $inner_result = $inner_result || $operands1->is_equal($operands2, $numberoffset);
                    if ($inner_result === true) break;
                }
                $result = $result && $inner_result;
                if ($result === false) break;
            }
            return $result;
        }
    }
}

/**
 * Defines lookaround assertions, unary operator.
 */
class qtype_preg_node_assert extends qtype_preg_operator {

    /** Positive lookahead assert. */
    const SUBTYPE_PLA = 'pla_node_assert';
    /** Negative lookahead assert. */
    const SUBTYPE_NLA = 'nla_node_assert';
    /** Positive lookbehind assert. */
    const SUBTYPE_PLB = 'plb_node_assert';
    /** Negative lookbehind assert. */
    const SUBTYPE_NLB = 'nlb_node_assert';

    public function __construct($subtype = null) {
        $this->type = qtype_preg_node::TYPE_NODE_ASSERT;
        $this->subtype = $subtype;
    }

    public function tohr() {
        return 'node assert';
    }

    public function is_subpattern() {
        return true;    // Lookaround assertion is a subpattern.
    }

    public function calculate_nflf(&$followpos) {
        // parent::calculate_nflf($followpos);
        $this->nullable = false;
        $this->firstpos = array($this->id);
        $this->lastpos = array($this->id);
    }

    // TODO - ui_nodename().
}

/**
 * Defines subexpressions (yes, NOT a subpattern), unary operator.
 */
class qtype_preg_node_subexpr extends qtype_preg_operator {

    /** Subexpression. */
    const SUBTYPE_SUBEXPR = 'subexpr_node_subexpr';
    /** Once-only subexpression. */
    const SUBTYPE_ONCEONLY = 'onceonly_node_subexpr';
    /** Grouping node. For author's tools only.*/
    const SUBTYPE_GROUPING = 'grouping_node_subexpr';

    /** Subexpression number. */
    public $number;
    /** Subexpression name. */
    public $name;
    /** Is this a duplicate subexpression number or name? */
    public $isduplicate;

    public function __construct($subtype, $number = null, $name = null, $isduplicate = false) {
        $this->type = qtype_preg_node::TYPE_NODE_SUBEXPR;
        $this->subtype = $subtype;
        $this->number = $number;
        $this->name = $name;
        $this->isduplicate = $isduplicate;
    }

    public function is_subpattern() {
        return true;    // Subexpression is a subpattern.
    }

    public function lang_key($usedescription = false) {
        $result = parent::lang_key($usedescription);
        if ($usedescription && $this->name !== null) {
            $result .= '_name';
        }
        return $result;
    }

    // TODO - ui_nodename().

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            && (($this->number!==null)?($this->number - $numberoffset):null) === $node->number
            /*&& $this->name==$node->name*/;
    }
}

/**
 * Defines conditional subexpressions, unary, binary or ternary operator.
 * The first operand yes-pattern, second - no-pattern, third - the lookaround assertion (if any).
 * Possible errors: there is no backreference with such number in expression
 */
class qtype_preg_node_cond_subexpr extends qtype_preg_operator {

    /** Absolute/relative/named references to subexpressions. */
    const SUBTYPE_SUBEXPR = 'subexpr_node_cond_subexpr';
    /** Recursion condition. */
    const SUBTYPE_RECURSION = 'recursion_node_cond_subexpr';
    /** Define subexpression for reference. */
    const SUBTYPE_DEFINE = 'define_node_cond_subexpr';
    /** Positive lookahead assert. */
    const SUBTYPE_PLA = 'pla_node_cond_subexpr';
    /** Negative lookahead assert. */
    const SUBTYPE_NLA = 'nla_node_cond_subexpr';
    /** Positive lookbehind assert. */
    const SUBTYPE_PLB = 'plb_node_cond_subexpr';
    /** Negative lookbehind assert. */
    const SUBTYPE_NLB = 'nlb_node_cond_subexpr';

    /** Subexpression number to refer to. */
    public $number;
    /** Subexpression name to refer to. */
    public $name;

    public function __construct($subtype = null, $number = null, $name = null, $condbranch = null) {
        $this->type = qtype_preg_node::TYPE_NODE_COND_SUBEXPR;
        $this->subtype = $subtype;
        $this->number = $number;
        $this->name = $name;
        $this->operands = $condbranch === null ? array() : array($condbranch);   // Assertion condition is the first operand.
    }

    public function is_condition_assertion() {
        return $this->subtype == self::SUBTYPE_PLA || $this->subtype == self::SUBTYPE_NLA || $this->subtype == self::SUBTYPE_PLB || $this->subtype == self::SUBTYPE_NLB;
    }

    public function is_subpattern() {
        return true;    // Conditional subexpression is a subpattern.
    }

    public function calculate_nflf(&$followpos) {
        parent::calculate_nflf($followpos);
        // TODO what should be here?
    }

    public function lang_key($usedescription = false) {
        if (!$usedescription) {
            return parent::lang_key($usedescription);
        }
        $result = $this->is_condition_assertion()
            ? 'description_' . $this->type
            : 'description_' . $this->subtype;

        if ($this->number === 0) {
            $result .= '_all';
        } else if ($this->name !== null) {
            $result .= '_name';
        }
        return $result;
    }

    // TODO - ui_nodename().

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            && (($this->number!==null)?($this->number - $numberoffset):null) === $node->number
            /*&& $this->name==$node->name*/;
    }
}

class qtype_preg_node_template extends qtype_preg_operator {
    public $name;
    public function __construct($name = '') {
        $this->type = qtype_preg_node::TYPE_NODE_TEMPLATE;
        $this->name = $name;
    }
    public function is_subpattern() {
        return false;   // TODO: child's value?
    }

    public function is_equal($node, $numberoffset) {
        return parent::is_equal($node, $numberoffset)
            && $this->name==$node->name;
    }

    public function is_expandable() {
        return false;
    }
}

/**
 * Defines error nodes, used when syntax errors in the regular expression occur.
 */
class qtype_preg_node_error extends qtype_preg_operator {

    const SUBTYPE_UNKNOWN_ERROR                = 'unknown_error_node_error';                  // Unknown parse error.
    const SUBTYPE_MISSING_OPEN_PAREN           = 'missing_open_paren_node_error';             // Closing paren without opening  xxx).
    const SUBTYPE_MISSING_TEMPLATE_OPEN_PAREN  = 'missing_template_open_paren_node_error';    // Closing template 'paren' without opening  xxx(?###>).
    const SUBTYPE_MISSING_CLOSE_PAREN          = 'missing_close_paren_node_error';            // Opening paren without closing  (xxx.
    const SUBTYPE_MISSING_TEMPLATE_CLOSE_PAREN = 'missing_template_close_paren_node_error';   // Opening template 'paren' without closing  (?###smth<)xxx.
    const SUBTYPE_MISSING_COMMENT_ENDING       = 'missing_comment_ending_node_error';         // Missing ) after comment.
    const SUBTYPE_MISSING_CONDSUBEXPR_ENDING   = 'missing_condsubexpr_ending_node_error';     // Missing conditional subexpression name ending.
    const SUBTYPE_MISSING_CALLOUT_ENDING       = 'missing_callout_ending_node_error';         // Missing ) after (?C.
    const SUBTYPE_MISSING_CONTROL_ENDING       = 'missing_control_ending_node_error';         // Missing ) after control sequence.
    const SUBTYPE_MISSING_SUBEXPR_NAME_ENDING  = 'missing_subexpr_name_ending_node_error';    // Missing subexpression name ending.
    const SUBTYPE_MISSING_BRACKETS_FOR_G       = 'missing_brackets_for_g_node_error';         // \g is not followed by {}, <>, or ''.
    const SUBTYPE_MISSING_BRACKETS_FOR_K       = 'missing_brackets_for_k_node_error';         // \k is not followed by {}, <>, or ''.
    const SUBTYPE_UNCLOSED_CHARSET             = 'unclosed_charset_node_error';               // Unclosed brackets in a character set.
    const SUBTYPE_POSIX_CLASS_OUTSIDE_CHARSET  = 'posix_class_outside_charset_node_error';    // POSIX class ouside of a character set.
    const SUBTYPE_QUANTIFIER_WITHOUT_PARAMETER = 'quantifier_without_parameter_node_error';   // Quantifier at the start of the expression. NOTE: currently incompatible with PCRE which treats it as a character.
    const SUBTYPE_INCORRECT_QUANT_RANGE        = 'incorrect_quant_range_node_error';          // Incorrect quantifier ranges: {5,3}.
    const SUBTYPE_INCORRECT_CHARSET_RANGE      = 'incorrect_charset_range_node_error';        // Incorrect character set range: [z-a].
    const SUBTYPE_SET_UNSET_MODIFIER           = 'set_unset_same_modifier_node_error';        // Set and unset same modifier at ther same time.
    const SUBTYPE_UNSUPPORTED_MODIFIER         = 'unsupported_modifier_node_error';           // Unsupported modifier.
    const SUBTYPE_UNKNOWN_UNICODE_PROPERTY     = 'unknown_unicode_property_node_error';       // Unknown unicode property.
    const SUBTYPE_UNKNOWN_POSIX_CLASS          = 'unknown_posix_class_node_error';            // Unknown posix class.
    const SUBTYPE_UNKNOWN_CONTROL_SEQUENCE     = 'unknown_control_sequence_node_error';       // Unknown control sequence (*...).
    const SUBTYPE_CONDSUBEXPR_TOO_MUCH_ALTER   = 'condsubexpr_too_much_alter_node_error';     // Too much top-level alternations in a conditional subexpression.
    const SUBTYPE_CONDSUBEXPR_ASSERT_EXPECTED  = 'condsubexpr_assert_expected_node_error';    // Assertion or condition expected.
    const SUBTYPE_CONSUBEXPR_ZERO_CONDITION    = 'condsubexpr_zero_condition_node_error';     // Invalid condition (?(0).
    const SUBTYPE_SLASH_AT_END_OF_PATTERN      = 'slash_at_end_of_pattern_node_error';        // \ at end of pattern.
    const SUBTYPE_C_AT_END_OF_PATTERN          = 'c_at_end_of_pattern_node_error';            // \c at end of pattern.
    const SUBTYPE_CX_SHOULD_BE_ASCII           = 'cx_should_be_ascii_node_error';             // \c should be followed by an ascii character.
    const SUBTYPE_UNEXISTING_SUBEXPR           = 'unexisting_subexpr_node_error';             // Reference to unexisting subexpression.
    const SUBTYPE_DUPLICATE_SUBEXPR_NAMES      = 'duplicate_subexpr_names_node_error';        // Two named subexpressions have the same name.
    const SUBTYPE_DIFFERENT_SUBEXPR_NAMES      = 'different_subexpr_names_node_error';        // Different subexpression names for subexpressions of the same number.
    const SUBTYPE_SUBEXPR_NAME_EXPECTED        = 'subexpr_name_expected_node_error';          // Subexpression name expected.
    const SUBTYPE_UNRECOGNIZED_PQH             = 'unrecognized_pqh_node_error';               // Unrecognized character after (? or (?-.
    const SUBTYPE_UNRECOGNIZED_PQLT            = 'unrecognized_pqlt_node_error';              // Unrecognized character after (?<.
    const SUBTYPE_UNRECOGNIZED_PQP             = 'unrecognized_pqp_node_error';               // Unrecognized character after (?P.
    const SUBTYPE_CHAR_CODE_TOO_BIG            = 'char_code_too_big_node_error';              // Character code too big.
    const SUBTYPE_CHAR_CODE_DISALLOWED         = 'char_code_disallowed_node_error';           // Character code disallowed.
    const SUBTYPE_CALLOUT_BIG_NUMBER           = 'callout_big_number_node_error';             // Too big number in (?C...).
    const SUBTYPE_LNU_UNSUPPORTED              = 'lnu_unsupported_node_error';                // \L, \l, \N{name}, \U, and \u are unsupported.
    const SUBTYPE_UNKNOWN_TEMPLATE             = 'unknown_template_node_error';               // Unknown template name.
    const SUBTYPE_WRONG_TEMPLATE_PARAMS_COUNT  = 'wrong_template_params_count_node_error';    // Incorrect number of parameters for a template.

    /** Additional info. */
    public $addinfo;

    public function __construct($subtype = null, $addinfo = null) {
        $this->type = qtype_preg_node::TYPE_NODE_ERROR;
        $this->subtype = $subtype;
        $this->addinfo = $addinfo;
    }

    public function is_subpattern() {
        return false;    // Of course it's not.
    }

    /**
     * Returns a user interface error string for the error, represented by this node.
     */
    public function error_string() {
        if ($this->subtype == self::SUBTYPE_UNKNOWN_ERROR) {
            return $this->addinfo;
        }
        $a = new stdClass;
        $a->linefirst = $this->position->linefirst;
        $a->linelast = $this->position->linelast;
        $a->colfirst = $this->position->colfirst;
        $a->collast = $this->position->collast;
        $a->addinfo = $this->addinfo;
        return get_string($this->subtype, 'qtype_preg', $a);
    }

    public function is_equal($node, $numberoffset) {
        return $this === $node;
    }
}
